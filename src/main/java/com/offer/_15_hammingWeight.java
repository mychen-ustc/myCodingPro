/**
 * // 15. 二进制中1的个数
 * // 难度：简单
 * // 请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。
 * //
 * // 示例 1：
 * //
 * // 输入：00000000000000000000000000001011
 * // 输出：3
 * // 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
 * // 示例 2：
 * //
 * // 输入：00000000000000000000000010000000
 * // 输出：1
 * // 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
 * // 示例 3：
 * //
 * // 输入：11111111111111111111111111111101
 * // 输出：31
 * //
 * // 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
 * //
 * // 注意：
 * // >>：带符号右移。正数右移高位补0，负数右移高位补1。比如：
 * // 4 >> 1，结果是2；-4 >> 1，结果是-2。-2 >> 1，结果是-1。
 * // >>>：无符号右移。无论是正数还是负数，高位通通补0。
 * // 对于正数而言，>>和>>>没区别。
 * // 对于负数而言，-2 >>> 1，结果是2147483647（Integer.MAX_VALUE），-1 >>> 1，结果是2147483647（Integer.MAX_VALUE）。
 */

package com.offer;

class Solution_15 {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        // 思路1：位运算
//        int ans = 0;
//        while (n != 0) {
//            ans += n & 1;
//            n >>>= 1;   // 要用>>>无符号右移，不能用>>
//        }
//        return ans;

        // 思路2：巧用 n&(n-1)
        // (n−1) 解析： 结果是将二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。
        // n&(n-1) 解析： 二进制数字 n 最右边的 1 变成 0 ，其余不变。
        int ans = 0;
        while (n != 0) {
            ans++;
            n &= (n - 1);
        }
        return ans;
    }
}

public class _15_hammingWeight {
    public static void main(String[] args) {
        Solution_15 solution = new Solution_15();
        int ans = solution.hammingWeight(00000000000000000000000010000000);
        System.out.println(ans);
    }
}
